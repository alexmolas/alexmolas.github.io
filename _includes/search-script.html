<script>
(function() {
  let selectedIndex = -1;
  let filteredResults = [];
  let lastQuery = '';
  let restoreFocusEl = null;

  function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function debounce(fn, delay) {
    let timer = null;
    return function(...args) {
      clearTimeout(timer);
      timer = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  // Simple fuzzy search function (for title only)
  function fuzzySearch(query, text) {
    query = query.toLowerCase();
    text = text.toLowerCase();
    let queryIndex = 0;
    let textIndex = 0;
    while (queryIndex < query.length && textIndex < text.length) {
      if (query[queryIndex] === text[textIndex]) {
        queryIndex++;
      }
      textIndex++;
    }
    return queryIndex === query.length;
  }

  // Calculate search score with tokenization
  function calculateScore(post, rawQuery) {
    const query = rawQuery.toLowerCase().trim();
    if (!query) return 0;

    const tokens = query.split(/\s+/).filter(Boolean);
    if (tokens.length === 0) return 0;

    const title = post.title.toLowerCase();
    const content = (post.content || '').toLowerCase();
    const excerpt = (post.excerpt || '').toLowerCase();
    const tags = Array.isArray(post.tags) ? post.tags.map(t => (t || '').toLowerCase()) : [];

    let score = 0;
    let unmatchedTokens = 0;

    for (const token of tokens) {
      const tokenRegex = new RegExp(escapeRegex(token), 'g');
      let matchedAny = false;

      if (title.includes(token)) {
        score += 1000;
        matchedAny = true;
        if (title.startsWith(token)) {
          score += 500;
        }
      } else if (fuzzySearch(token, title)) {
        score += 200; // Typo tolerance in title only
        matchedAny = true;
      }

      if (excerpt.includes(token)) {
        score += 300;
        matchedAny = true;
      }

      if (content.includes(token)) {
        score += 50;
        matchedAny = true;
        const matches = (content.match(tokenRegex) || []).length;
        if (matches > 1) {
          score += Math.min(matches * 10, 50);
        }
      }

      if (tags.some(tag => tag.includes(token))) {
        score += 400;
        matchedAny = true;
      }

      if (!matchedAny) {
        unmatchedTokens += 1;
      }
    }

    // Recency boost (lightweight)
    const dateMs = Date.parse(post.date);
    if (!Number.isNaN(dateMs)) {
      const daysAgo = (Date.now() - dateMs) / (1000 * 60 * 60 * 24);
      // Up to +100 for very recent posts, decays over ~1 year
      const recencyBoost = Math.max(0, 100 - Math.min(365, daysAgo) / 3.65);
      score += Math.round(recencyBoost);
    }

    if (unmatchedTokens > 0) return 0;

    return score >= 50 ? score : 0;
  }

  // Highlight matching text for all tokens
  function highlightText(text, rawQuery) {
    const query = (rawQuery || '').trim();
    if (!query) return text;
    const tokens = query.split(/\s+/).filter(Boolean).map(escapeRegex);
    if (tokens.length === 0) return text;
    const regex = new RegExp(`(${tokens.join('|')})`, 'gi');
    return text.replace(regex, '<span class="search-highlight">$1</span>');
  }

  // Perform search
  function performSearch(query) {
    lastQuery = query;
    const resultsContainer = document.getElementById('searchResults');

    if (!query.trim()) {
      resultsContainer.innerHTML = `
        <div class="search-empty-state">
          <p>Start typing to search through all blog posts...</p>
        </div>
      `;
      filteredResults = [];
      selectedIndex = -1;
      return;
    }

    const results = (window.searchIndex || [])
      .map(post => ({
        ...post,
        score: calculateScore(post, query)
      }))
      .filter(post => post.score > 0)
      .sort((a, b) => b.score - a.score)
      .slice(0, 10);

    filteredResults = results;
    selectedIndex = -1;

    if (results.length === 0) {
      const wrapper = document.createElement('div');
      wrapper.className = 'search-no-results';
      const p = document.createElement('p');
      p.textContent = `No posts found for "${query}"`;
      wrapper.appendChild(p);
      resultsContainer.innerHTML = '';
      resultsContainer.appendChild(wrapper);
      return;
    }

    const resultsHTML = results.map((post, index) => `
      <div class="search-result-item" data-index="${index}" tabindex="0" role="option" aria-selected="${index === selectedIndex}" onclick="navigateToPost('${post.url}')" onkeydown="if(event.key==='Enter'){navigateToPost('${post.url}')}" >
        <div class="search-result-title">
          ${highlightText(post.title, query)}
        </div>
        <div class="search-result-meta">
          ${post.date}
        </div>
        <div class="search-result-excerpt">
          ${highlightText(post.excerpt, query)}
        </div>
      </div>
    `).join('');

    resultsContainer.innerHTML = resultsHTML;
  }

  // Navigate to selected post
  function navigateToPost(url) {
    window.location.href = url;
  }

  // Update selection highlighting and aria
  function updateSelection() {
    const items = document.querySelectorAll('.search-result-item');
    items.forEach((item, index) => {
      const selected = index === selectedIndex;
      item.classList.toggle('selected', selected);
      item.setAttribute('aria-selected', String(selected));
      if (selected) {
        item.scrollIntoView({ block: 'nearest' });
      }
    });
  }

  // Focus trap within the modal
  function trapFocus(e) {
    if (e.key !== 'Tab') return;
    const modal = document.getElementById('searchModal');
    const focusable = modal.querySelectorAll('#searchInput, .search-result-item');
    if (focusable.length === 0) return;
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    const active = document.activeElement;

    if (!e.shiftKey && active === last) {
      e.preventDefault();
      first.focus();
    } else if (e.shiftKey && active === first) {
      e.preventDefault();
      last.focus();
    }
  }

  // Handle keyboard navigation
  function handleKeyDown(e) {
    const modal = document.getElementById('searchModal');
    const isModalOpen = modal.style.display === 'block';

    // Cmd+K or Ctrl+K to open search
    if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'k') {
      e.preventDefault();
      openSearch();
      return;
    }

    if (!isModalOpen) return;

    switch (e.key) {
      case 'Escape':
        e.preventDefault();
        closeSearch();
        break;
      case 'ArrowDown':
        e.preventDefault();
        selectedIndex = Math.min(selectedIndex + 1, filteredResults.length - 1);
        updateSelection();
        break;
      case 'ArrowUp':
        e.preventDefault();
        selectedIndex = Math.max(selectedIndex - 1, -1);
        updateSelection();
        break;
      case 'Enter':
        e.preventDefault();
        if (selectedIndex >= 0 && filteredResults[selectedIndex]) {
          navigateToPost(filteredResults[selectedIndex].url);
        } else if (filteredResults.length > 0) {
          navigateToPost(filteredResults[0].url);
        }
        break;
      default:
        break;
    }
  }

  // Open search modal
  function openSearch() {
    const modal = document.getElementById('searchModal');
    const input = document.getElementById('searchInput');

    restoreFocusEl = document.activeElement;

    modal.style.display = 'block';
    input.focus();
    // Preserve last query
    input.value = lastQuery;
    performSearch(lastQuery);

    // Prevent body scroll when modal is open
    document.body.style.overflow = 'hidden';

    // Add focus trap
    modal.addEventListener('keydown', trapFocus);
  }

  // Close search modal
  function closeSearch() {
    const modal = document.getElementById('searchModal');
    modal.style.display = 'none';
    selectedIndex = -1;
    filteredResults = [];

    // Restore body scroll
    document.body.style.overflow = '';

    // Remove focus trap
    modal.removeEventListener('keydown', trapFocus);

    // Restore focus to the trigger element if available
    if (restoreFocusEl && typeof restoreFocusEl.focus === 'function') {
      restoreFocusEl.focus();
    }
  }

  // Make functions global for onclick handlers
  window.navigateToPost = navigateToPost;
  window.openSearchModal = openSearch;

  // Initialize search functionality when DOM is loaded
  document.addEventListener('DOMContentLoaded', function() {
    // Global keyboard listener
    document.addEventListener('keydown', handleKeyDown);

    // Search input listener (debounced)
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
      const debounced = debounce((val) => performSearch(val), 150);
      searchInput.addEventListener('input', function(e) {
        debounced(e.target.value);
      });
    }

    // Close modal when clicking outside
    const modal = document.getElementById('searchModal');
    if (modal) {
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          closeSearch();
        }
      });
    }
  });
})();
</script> 