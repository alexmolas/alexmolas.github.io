<script>
(function() {
  let selectedIndex = -1;
  let filteredResults = [];
  let lastQuery = '';
  let restoreFocusEl = null;

  function debounce(fn, delay) {
    let timer = null;
    return function(...args) {
      clearTimeout(timer);
      timer = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  // Highlight matching text for search terms
  function highlightText(text, query) {
    if (!query || !text) return text;
    const terms = query.toLowerCase().split(/\s+/).filter(Boolean);
    if (terms.length === 0) return text;
    
    const regex = new RegExp(`(${terms.map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})`, 'gi');
    return text.replace(regex, '<span class="search-highlight">$1</span>');
  }

  // Extract relevant snippet from content with highlighting
  function extractSnippet(content, query, maxLength = 150) {
    if (!query || !content) return content.substring(0, maxLength) + (content.length > maxLength ? '...' : '');
    
    const terms = query.toLowerCase().split(/\s+/).filter(Boolean);
    if (terms.length === 0) return content.substring(0, maxLength) + (content.length > maxLength ? '...' : '');
    
    const lowerContent = content.toLowerCase();
    let bestMatch = { index: 0, score: 0 };
    
    // Find the position with the most query terms nearby
    for (const term of terms) {
      const index = lowerContent.indexOf(term);
      if (index !== -1) {
        let score = 1;
        // Count other terms nearby
        for (const otherTerm of terms) {
          if (otherTerm !== term) {
            const otherIndex = lowerContent.indexOf(otherTerm, Math.max(0, index - 100));
            if (otherIndex !== -1 && Math.abs(otherIndex - index) < 200) {
              score++;
            }
          }
        }
        if (score > bestMatch.score) {
          bestMatch = { index, score };
        }
      }
    }
    
    // Extract snippet around the best match
    const start = Math.max(0, bestMatch.index - Math.floor(maxLength / 2));
    const end = Math.min(content.length, start + maxLength);
    let snippet = content.substring(start, end);
    
    // Add ellipsis
    if (start > 0) snippet = '...' + snippet;
    if (end < content.length) snippet = snippet + '...';
    
    return highlightText(snippet, query);
  }

  // Perform search using Lunr.js
  function performSearch(query) {
    lastQuery = query;
    const resultsContainer = document.getElementById('searchResults');

    if (!query.trim()) {
      resultsContainer.innerHTML = `
        <div class="search-empty-state">
          <p>Start typing to search through all blog posts...</p>
        </div>
      `;
      filteredResults = [];
      selectedIndex = -1;
      return;
    }

    try {
      const searchResults = window.searchIndex.search(query);
      const results = searchResults.slice(0, 10).map(result => {
        const doc = window.documents[parseInt(result.ref)];
        return {
          ...doc,
          score: result.score
        };
      });

      filteredResults = results;
      selectedIndex = -1;

      if (results.length === 0) {
        const wrapper = document.createElement('div');
        wrapper.className = 'search-no-results';
        const p = document.createElement('p');
        p.textContent = `No posts found for "${query}"`;
        wrapper.appendChild(p);
        resultsContainer.innerHTML = '';
        resultsContainer.appendChild(wrapper);
        return;
      }

      const totalResults = searchResults.length;
      const displayedResults = results.length;
      
      const resultsCountHTML = `
        <div class="search-results-count">
          ${totalResults === displayedResults 
            ? `${totalResults} result${totalResults === 1 ? '' : 's'} found` 
            : `Showing ${displayedResults} of ${totalResults} results`}
        </div>
      `;

      const resultsHTML = results.map((post, index) => `
        <div class="search-result-item" data-index="${index}" tabindex="0" role="option" aria-selected="${index === selectedIndex}" onclick="navigateToPost('${post.url}')" onkeydown="if(event.key==='Enter'){navigateToPost('${post.url}')}" >
          <div class="search-result-title">
            ${highlightText(post.title, query)}
          </div>
          <div class="search-result-meta">
            ${post.date}
          </div>
          <div class="search-result-excerpt">
            ${extractSnippet(post.content || post.excerpt, query)}
          </div>
        </div>
      `).join('');

      resultsContainer.innerHTML = resultsCountHTML + resultsHTML;
    } catch (error) {
      console.error('Search error:', error);
      resultsContainer.innerHTML = `
        <div class="search-no-results">
          <p>Search error. Please try a different query.</p>
        </div>
      `;
    }
  }

  // Navigate to selected post
  function navigateToPost(url) {
    window.location.href = url;
  }

  // Update selection highlighting and aria
  function updateSelection() {
    const items = document.querySelectorAll('.search-result-item');
    items.forEach((item, index) => {
      const selected = index === selectedIndex;
      item.classList.toggle('selected', selected);
      item.setAttribute('aria-selected', String(selected));
      if (selected) {
        item.scrollIntoView({ block: 'nearest' });
      }
    });
  }

  // Focus trap within the modal
  function trapFocus(e) {
    if (e.key !== 'Tab') return;
    const modal = document.getElementById('searchModal');
    const focusable = modal.querySelectorAll('#searchInput, .search-result-item');
    if (focusable.length === 0) return;
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    const active = document.activeElement;

    if (!e.shiftKey && active === last) {
      e.preventDefault();
      first.focus();
    } else if (e.shiftKey && active === first) {
      e.preventDefault();
      last.focus();
    }
  }

  // Handle keyboard navigation
  function handleKeyDown(e) {
    const modal = document.getElementById('searchModal');
    const isModalOpen = modal.style.display === 'block';

    // Cmd+K or Ctrl+K to open search
    if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'k') {
      e.preventDefault();
      openSearch();
      return;
    }

    if (!isModalOpen) return;

    switch (e.key) {
      case 'Escape':
        e.preventDefault();
        closeSearch();
        break;
      case 'ArrowDown':
        e.preventDefault();
        selectedIndex = Math.min(selectedIndex + 1, filteredResults.length - 1);
        updateSelection();
        break;
      case 'ArrowUp':
        e.preventDefault();
        selectedIndex = Math.max(selectedIndex - 1, -1);
        updateSelection();
        break;
      case 'Enter':
        e.preventDefault();
        if (selectedIndex >= 0 && filteredResults[selectedIndex]) {
          navigateToPost(filteredResults[selectedIndex].url);
        } else if (filteredResults.length > 0) {
          navigateToPost(filteredResults[0].url);
        }
        break;
      default:
        break;
    }
  }

  // Open search modal
  function openSearch() {
    const modal = document.getElementById('searchModal');
    const input = document.getElementById('searchInput');

    restoreFocusEl = document.activeElement;

    modal.style.display = 'block';
    input.focus();
    // Preserve last query
    input.value = lastQuery;
    performSearch(lastQuery);

    // Prevent body scroll when modal is open
    document.body.style.overflow = 'hidden';

    // Add focus trap
    modal.addEventListener('keydown', trapFocus);
  }

  // Close search modal
  function closeSearch() {
    const modal = document.getElementById('searchModal');
    modal.style.display = 'none';
    selectedIndex = -1;
    filteredResults = [];

    // Restore body scroll
    document.body.style.overflow = '';

    // Remove focus trap
    modal.removeEventListener('keydown', trapFocus);

    // Restore focus to the trigger element if available
    if (restoreFocusEl && typeof restoreFocusEl.focus === 'function') {
      restoreFocusEl.focus();
    }
  }

  // Make functions global for onclick handlers
  window.navigateToPost = navigateToPost;
  window.openSearchModal = openSearch;

  // Initialize search functionality when DOM is loaded
  document.addEventListener('DOMContentLoaded', function() {
    // Global keyboard listener
    document.addEventListener('keydown', handleKeyDown);

    // Search input listener (debounced)
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
      const debounced = debounce((val) => performSearch(val), 150);
      searchInput.addEventListener('input', function(e) {
        debounced(e.target.value);
      });
    }

    // Close modal when clicking outside
    const modal = document.getElementById('searchModal');
    if (modal) {
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          closeSearch();
        }
      });
    }
  });
})();
</script>